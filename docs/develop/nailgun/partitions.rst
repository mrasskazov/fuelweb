Creating Partitions on Nodes
============================

Fuel uses Cobbler and Anaconda Kickstart to partition block devices on
new nodes. Most of the work is done in the *pmanager.py* Cobbler script
(found under templates/scripts/ in the Cobbler Puppet module) using the
data from the "ks_spaces" Cobbler variable generated by the *Nailgun
VolumeManager* class (nailgun/volumes/manager.py) based on the volumes
metadata defined in the *openstack.json* release fixture
(nailgun/fixtures/).

The preferred type of a volume for a Fuel slave node is "vg": an LVM
volume group that can contain one or more volumes with type set to "lv".
In cases where LVM is not suitable, it is also possible to create plain
partitions by setting volume type to "partition".

Typical slave node will always have an "os" volume group and one or more
volumes of other types, depending on the roles assigned to that node and
the role-to-volumes mapping defined in the "volumes_roles_mapping"
section of openstack.json.

There are a few different ways to add another volume to a slave node:

#. Add a new logical volume definition to one of the existing LVM volume
   groups.
#. Create a new volume group containing your new logical volumes.
#. Create a new plain partition.

Adding an LV to an Existing Volume Group
----------------------------------------

If you need to add a new volume to an existing volume group, for
example "os", your volume definition in openstack.json will look like
this::

  {
    "id": "os",
    "type": "vg",
    "min_size": {"generator": "calc_min_os_size"},
    "label": "Base System",
    "volumes": [
        {
            "mount": "/",
            "type": "lv",
            "name": "root",
            "size": {"generator": "calc_total_root_vg"},
            "file_system": "ext4"
        },
        {
            "mount": "swap",
            "type": "lv",
            "name": "swap",
            "size": {"generator": "calc_swap_size"},
            "file_system": "swap"
        },
        {
            "mount": "/mnt/some/path",
            "type": "lv",
            "name": "LOGICAL_VOLUME_NAME",
            "size": {
                "generator": "calc_LOGICAL_VOLUME_size",
                "generator_args": ["arg1", "arg2"]
            },
            "file_system": "ext4"
        }
    ]
  }

Make sure that your logical volume name ("LOGICAL_VOLUME_NAME" in the
example above) is not the same as the volume group name ("os").

Adding Generators to Nailgun VolumeManager
------------------------------------------

The "size" field in a volume definition can be defined either directly
as an integer number in megabytes, or indirectly via a so called
generator. Generator is a Python lambda that can be called to calculate
logical volume size dynamically. In the json example above size is
defined as a dictionary with two keys: "generator" is the name of the
generator lambda and "generator_args" is the list of arguments that will
be passed to the generator lambda.

There is the method in the VolumeManager class where generators are
defined. New volume generator 'NEW_GENERATOR_TO_CALCULATE_SIZ' needs to
be added in the generators dictionary inside this method.

.. code-block:: python

    class VolumeManager(object):
        ...
        def call_generator(self, generator, *args):
            generators = {
                ...
                'NEW_GENERATOR_TO_CALCULATE_SIZE': lambda: 1000,
                ...
            }


Creating a New Volume Group
---------------------------

Another way to add new volume to slave nodes is to create new volume
group and to define one or more logical volume inside the volume group
definition::

    {
        "id": "NEW_VOLUME_GROUP_NAME",
        "type": "vg",
        "min_size": {"generator": "calc_NEW_VOLUME_NAME_size"},
        "label": "Label for NEW VOLUME GROUP as it will be shown on UI",
        "volumes": [
            {
                "mount": "/path/to/mount/point",
                "type": "lv",
                "name": "LOGICAL_VOLUME_NAME",
                "size": {
                    "generator": "another_generator_to_calc_LOGICAL_VOLUME_size",
                    "generator_args": ["arg"]
                },
                "file_system": "xfs"
            }
        ]
    }

Creating a New Plain Partition
------------------------------

Some node roles may be incompatible with LVM and would require plain
partitions. If that's the case, you may have to define a standalone
volume with type "partition" instead of "vg"::

    {
        "id": "NEW_PARTITION_NAME",
        "type": "partition",
        "min_size": {"generator": "calc_NEW_PARTITION_NAME_size"},
        "label": "Label for NEW PARTITION as it will be shown on UI",
        "mount": "none",
        "disk_label": "LABEL",
        "file_system": "xfs"
    }

Note how you can set mount point to "none" and define a disk label to
identify the partition instead. Its only possible to set a disk label on
a formatted portition, so you have to set "file_system" parameter to use
disk labels.

Updating the Node Role to Volumes Mapping
-----------------------------------------

Unlike a new logical volume added to a pre-existing logical volume
group, a new logical volume group or partition will not be allocated on
the node unless it is included in the role-to-volumes mapping
corresponding to one of the node's roles, like this::

    {
        "volumes_roles_mapping": {
            "controller": ["os", "image"],
            "compute": ["os", "vm", "VOLUME_GROUP_NAME"],
            "cinder": ["os", "cinder"]
        }
    }

Setting Volume Parameters from Nailgun Settings
-----------------------------------------------

In addition to VolumeManager generators, it is also possible to define
sizes or whatever you want in the nailgun configuration file
(/etc/nailgun/settings.yaml). All fixture files are templated using
Jinja2 templating engine just before being loaded into nailgun database.
For example, we can define mount point for a new volume as follows::

    "mount": "{{settings.NEW_LOGICAL_VOLUME_MOUNT_POINT}}"

Of course, *NEW_LOGICAL_VOLUME_MOUNT_POINT* must be defined in the
settings file.

